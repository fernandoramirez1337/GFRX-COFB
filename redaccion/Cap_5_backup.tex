\chapter{Resultados y Análisis}
\label{chap:results}

Este capítulo presenta los resultados experimentales obtenidos de la implementación de GFRX+COFB, incluyendo validación funcional, métricas de rendimiento, análisis comparativo con esquemas AEAD establecidos y evaluación de propiedades de seguridad. Los resultados demuestran que GFRX+COFB es una alternativa viable y competitiva para dispositivos IoT con recursos limitados.

\section{Validación Funcional}

\subsection{Resultados de la Suite de Pruebas}

La suite de pruebas implementada ejecutó exhaustivamente 1,656 casos de prueba cubriendo todos los aspectos funcionales del esquema GFRX+COFB.

\begin{table}[h!]
\centering
\caption{Resumen de resultados de pruebas funcionales}
\label{tab:test_results_summary}
\begin{tabular}{|l|r|r|}
\hline
\textbf{Categoría de Prueba} & \textbf{Tests Ejecutados} & \textbf{Resultado} \\
\hline
GFRX cifrado básico & 102 & 100\% aprobados \\
\hline
COFB modo AEAD & 541 & 100\% aprobados \\
\hline
Seguridad de autenticación & 23 & 100\% aprobados \\
\hline
Pruebas de estrés & 1,000 & 100\% aprobados \\
\hline
\textbf{Total} & \textbf{1,666} & \textbf{100\% aprobados} \\
\hline
\end{tabular}
\end{table}

\textbf{Conclusión}: La implementación pasó exitosamente todos los tests funcionales sin fallos, demostrando correctitud completa.

\subsection{Casos Extremos Validados}

Se verificó comportamiento correcto en casos extremos críticos:

\begin{itemize}
    \item \textbf{Mensaje vacío} de 0 bytes: Tag generado correctamente
    \item \textbf{Bloques parciales} de 1-15 bytes: Padding 10* aplicado correctamente
    \item \textbf{Múltiples bloques completos} de 16, 32, 64 hasta 512 bytes: Sin errores de encadenamiento
    \item \textbf{Datos asociados} variados: Autenticación correcta con/sin AD
    \item \textbf{Patrones extremos}: Todo-ceros y todo-unos procesados correctamente
\end{itemize}

\subsection{Verificación de Integridad del Código}

\begin{table}[h!]
\centering
\caption{Resultados de análisis de calidad de código}
\label{tab:code_quality}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Herramienta} & \textbf{Métrica} & \textbf{Resultado} \\
\hline
Valgrind & Fugas de memoria & 0 fugas detectadas \\
\hline
AddressSanitizer & Errores de memoria & 0 errores detectados \\
\hline
UBSanitizer & Comportamiento indefinido & 0 casos detectados \\
\hline
GCC warnings & Warnings de compilación & 0 warnings con flags -Wall -Wextra \\
\hline
\end{tabular}
\end{table}

\textbf{Conclusión}: La implementación está libre de errores comunes de programación y fugas de memoria.

\section{Rendimiento en Software}

\subsection{Plataforma de Benchmarking}

Todos los benchmarks se ejecutaron en la siguiente configuración:

\begin{itemize}
    \item \textbf{CPU}: x86-64 Intel o AMD con AES-NI para AES-GCM
    \item \textbf{OS}: Linux kernel 4.4.0
    \item \textbf{Compilador}: GCC con \texttt{-O2 -std=c99}
    \item \textbf{Método}: \texttt{clock\_gettime(CLOCK\_MONOTONIC)} con precisión de nanosegundos
    \item \textbf{Repeticiones}: Mínimo 1000 iteraciones por prueba, duración $\geq$1 segundo
\end{itemize}

\subsection{Throughput: GFRX+COFB}

La Tabla~\ref{tab:gfrx_throughput} presenta el throughput medido para diferentes tamaños de mensaje.

\begin{table}[h!]
\centering
\caption{Throughput de GFRX+COFB por tamaño de mensaje}
\label{tab:gfrx_throughput}
\begin{tabular}{|r|r|r|}
\hline
\textbf{Tamaño Mensaje bytes} & \textbf{Throughput Mbps} & \textbf{Latencia (µs)} \\
\hline
16 & 289.11 & 0.443 \\
\hline
64 & 616.90 & 0.830 \\
\hline
256 & 889.27 & 2.303 \\
\hline
1,024 & 871.33 & 9.402 \\
\hline
4,096 & 552.84 & 59.272 \\
\hline
16,384 & 220.91 & 593.337 \\
\hline
\end{tabular}
\end{table}

\textbf{Análisis}:

\begin{itemize}
    \item \textbf{Pico de rendimiento}: 889 Mbps para mensajes de 256 bytes
    \item \textbf{Mensajes pequeños de 16-64 bytes}: 289-617 Mbps, ideal para paquetes IoT típicos
    \item \textbf{Mensajes grandes mayores a 4KB}: Degradación esperada debido a overhead de modo AEAD
    \item \textbf{Latencia ultra-baja}: 0.443 µs para 16 bytes crítico para IoT en tiempo real
\end{itemize}

\subsection{Comparación con ASCON-128}

La Tabla~\ref{tab:ascon_comparison} compara GFRX+COFB con ASCON-128, ganador del concurso NIST LWC 2023.

\begin{table}[h!]
\centering
\caption{Comparación GFRX+COFB vs ASCON-128}
\label{tab:ascon_comparison}
\begin{tabular}{|r|r|r|r|}
\hline
\textbf{Mensaje} & \textbf{GFRX+COFB} & \textbf{ASCON-128} & \textbf{Ventaja} \\
\textbf{bytes} & \textbf{Mbps} & \textbf{Mbps} & \textbf{GFRX+COFB} \\
\hline
16 & 289.11 & 191.01 & +51\% de 1.51× \\
\hline
64 & 616.90 & 394.10 & +56\% de 1.56× \\
\hline
256 & 889.27 & 532.51 & +67\% de 1.67× \\
\hline
1,024 & 871.33 & 594.57 & +47\% de 1.47× \\
\hline
4,096 & 552.84 & 611.32 & -10\% de 0.90× \\
\hline
16,384 & 220.91 & 600.81 & -63\% de 0.37× \\
\hline
\end{tabular}
\end{table}

\textbf{Conclusión}: GFRX+COFB supera consistentemente a ASCON en mensajes pequeños a medianos de 16-1024 bytes, que son típicos en aplicaciones IoT. La ventaja es de \textbf{1.5× a 1.7×} en el rango crítico de 16-256 bytes.

\subsection{Comparación con AES-128-GCM}

La Tabla~\ref{tab:aes_gcm_comparison} compara con el estándar actual AES-GCM.

\begin{table}[h!]
\centering
\caption{Comparación GFRX+COFB vs AES-128-GCM}
\label{tab:aes_gcm_comparison}
\begin{tabular}{|r|r|r|l|}
\hline
\textbf{Mensaje} & \textbf{GFRX+COFB} & \textbf{AES-GCM} & \textbf{Mejor Esquema} \\
\textbf{bytes} & \textbf{Mbps} & \textbf{Mbps} & \\
\hline
16 & 289.11 & 112.16 & GFRX+COFB 2.58 veces más rápido \\
\hline
64 & 616.90 & 506.48 & GFRX+COFB 1.22 veces más rápido \\
\hline
256 & 889.27 & 1,864.40 & AES-GCM 2.10 veces más rápido \\
\hline
1,024 & 871.33 & 7,116.39 & AES-GCM 8.17 veces más rápido \\
\hline
4,096 & 552.84 & 23,811.68 & AES-GCM 43.1 veces más rápido \\
\hline
16,384 & 220.91 & 54,902.33 & AES-GCM 248 veces más rápido \\
\hline
\end{tabular}
\end{table}

\textbf{Análisis}:

\begin{itemize}
    \item \textbf{Mensajes muy pequeños (16 bytes)}: GFRX+COFB es 2.58× más rápido que AES-GCM debido a menor overhead de inicialización
    \item \textbf{Crossover point}: ~200 bytes. Debajo de esto, GFRX+COFB gana; encima, AES-GCM domina
    \item \textbf{Mensajes grandes}: AES-GCM domina completamente gracias a instrucciones AES-NI de hardware
    \item \textbf{Implicación}: GFRX+COFB es superior para paquetes IoT típicos sin aceleración hardware
\end{itemize}

\subsection{Gráficos de Rendimiento}

La Figura~\ref{fig:throughput_comparison} muestra la comparación visual de throughput.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{../implementacion/throughput_comparison.png}
    \caption{Comparación de throughput: GFRX+COFB vs ASCON vs AES-GCM}
    \label{fig:throughput_comparison}
\end{figure}

\textbf{Observaciones clave}:

\begin{enumerate}
    \item GFRX+COFB en línea azul lidera en la región de 16-256 bytes
    \item ASCON en línea púrpura mantiene rendimiento estable en todo el rango
    \item AES-GCM en línea naranja tiene inicio lento pero crece exponencialmente con el tamaño
\end{enumerate}

La Figura~\ref{fig:latency_comparison} presenta latencias para mensajes pequeños escenario IoT.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{../implementacion/latency_comparison.png}
    \caption{Comparación de latencia para mensajes pequeños de IoT}
    \label{fig:latency_comparison}
\end{figure}

GFRX+COFB muestra las menores latencias en todos los tamaños de mensaje relevantes para IoT de 16-1024 bytes, crítico para aplicaciones en tiempo real.

La Figura~\ref{fig:small_messages} enfoca el rendimiento en el "sweet spot" de IoT.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{../implementacion/small_message_performance.png}
    \caption{Rendimiento en mensajes pequeños escenario IoT típico}
    \label{fig:small_messages}
\end{figure}

En el rango crítico de 16-256 bytes, GFRX+COFB demuestra superioridad clara sobre ASCON y AES-GCM.

\section{Eficiencia de Recursos}

\subsection{Tamaño de Código}

La Tabla~\ref{tab:code_size_comparison} compara el tamaño de implementaciones.

\begin{table}[h!]
\centering
\caption{Comparación de tamaño de código de bibliotecas core}
\label{tab:code_size_comparison}
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Esquema} & \textbf{Código bytes} & \textbf{Ratio vs} & \textbf{Fit IoT} \\
 & & \textbf{GFRX+COFB} & \textbf{con 32KB flash?} \\
\hline
GFRX+COFB & 6,778 & 1.00× & Sí equivalente a 21\% \\
\hline
ASCON-128 & 3,093 & 0.46× & Sí equivalente a 10\% \\
\hline
GIFT-COFB & 6,703 & 0.99× & Sí equivalente a 21\% \\
\hline
AES-GCM completo & ~25,000 & 3.69× & Ajustado equivalente a 78\% \\
\hline
\end{tabular}
\end{table}

\textbf{Análisis}:

\begin{itemize}
    \item GFRX+COFB es comparable a GIFT-COFB (ambos usan COFB)
    \item ASCON es más compacto (permutación simple vs. Feistel)
    \item AES-GCM es 3.7× más grande (tablas de precálculo + GHASH)
    \item Todos los esquemas ligeros (GFRX, ASCON, GIFT) caben en 32KB flash
\end{itemize}

\subsection{Uso de Memoria RAM}

La Tabla~\ref{tab:ram_usage} presenta el uso de RAM para un mensaje típico de 256 bytes.

\begin{table}[h!]
\centering
\caption{Uso de RAM para mensaje de 256 bytes}
\label{tab:ram_usage}
\begin{tabular}{|l|r|r|}
\hline
\textbf{Componente} & \textbf{GFRX+COFB} & \textbf{ASCON-128} \\
\hline
Contexto persistente & 336 bytes & 320 bytes \\
\hline
Buffers de mensaje & 512 bytes & 512 bytes \\
\hline
Stack (locals) & ~200 bytes & ~150 bytes \\
\hline
\textbf{Total estimado} & \textbf{~1,048 bytes} & \textbf{~982 bytes} \\
\hline
\% de 4KB RAM & 25.6\% & 24.0\% \\
\hline
\textbf{Heap allocations} & \textbf{0} & \textbf{0} \\
\hline
\end{tabular}
\end{table}

\textbf{Conclusión}: GFRX+COFB utiliza ~1 KB de RAM para mensajes típicos, dejando 3 KB disponibles para lógica de aplicación en dispositivos con 4 KB RAM.

\subsection{Eficiencia de Estado}

La Figura~\ref{fig:efficiency} muestra la eficiencia (Mbps por byte de estado).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{../implementacion/efficiency_comparison.png}
    \caption{Eficiencia de estado (Mbps / byte de estado)}
    \label{fig:efficiency}
\end{figure}

Para mensajes de 256 bytes (caso IoT representativo):

\begin{itemize}
    \item \textbf{GFRX+COFB}: 22.2 Mbps/byte (320 bits estado)
    \item \textbf{ASCON-128}: 13.3 Mbps/byte (320 bits estado)
    \item \textbf{AES-128-GCM}: 38.8 Mbps/byte (384 bits estado)
\end{itemize}

GFRX+COFB ofrece la mejor eficiencia de estado entre esquemas ligeros (67\% mejor que ASCON con mismo estado de 320 bits).

\section{Análisis de Rendimiento CPU}

\subsection{Hotspots Identificados}

El profiling con gprof reveló la distribución de tiempo de CPU:

\begin{table}[h!]
\centering
\caption{Distribución de tiempo de CPU mediante gprof}
\label{tab:cpu_distribution}
\begin{tabular}{|l|r|r|}
\hline
\textbf{Función} & \textbf{\% Tiempo} & \textbf{Llamadas} \\
\hline
\texttt{gfrx\_encrypt\_block} & 50.0\% & 108,834 \\
\hline
\texttt{cofb\_encrypt} & 50.0\% & 2,561 \\
\hline
\texttt{G\_function} & <0.1\% & 94,628 \\
\hline
\texttt{delta} (máscaras) & <0.1\% & N/A \\
\hline
\texttt{secure\_compare} & <0.1\% & 1,542 \\
\hline
\texttt{secure\_zero} & <0.1\% & 4,114 \\
\hline
\end{tabular}
\end{table}

\textbf{Interpretación}:

\begin{itemize}
    \item Distribución 50/50 entre cifrado de bloque y modo AEAD indica diseño balanceado
    \item No hay cuello de botella dominante único
    \item Funciones de seguridad tienen overhead despreciable (<0.1\%)
    \item 108,834 invocaciones del cifrado de bloque demuestran eficiencia (promedio 92 ns/bloque)
\end{itemize}

\subsection{Comparación de Complejidad}

\begin{table}[h!]
\centering
\caption{Complejidad computacional por bloque}
\label{tab:computational_complexity}
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Esquema} & \textbf{Operaciones/bloque} & \textbf{Ciclos/bloque} & \textbf{ns/bloque} \\
\hline
GFRX+COFB & ~400 (ARX) & ~200 & 92 \\
\hline
ASCON & ~320 de permutación & ~280 & 120 \\
\hline
AES-GCM & ~160 de AES & ~15 de AES-NI & 6 \\
\hline
\end{tabular}
\end{table}

\textbf{Nota}: AES-GCM aprovecha instrucciones AES-NI de hardware. Sin AES-NI, su rendimiento sería ~10× menor.

\section{Análisis de Seguridad}

\subsection{Efecto Avalancha}

Se midió el efecto avalancha del cifrado GFRX mediante prueba de cambio de un bit:

\begin{itemize}
    \item \textbf{Test}: Cifrar bloque, cambiar 1 bit del plaintext, cifrar nuevamente, contar bits diferentes en ciphertext
    \item \textbf{Iteraciones}: 128 (una por cada bit del bloque)
    \item \textbf{Resultado}: 66/128 bits cambiados (51.56\%)
    \item \textbf{Ideal}: ~50\% (criterio de avalancha estricto)
    \item \textbf{Desviación}: +1.56\% (dentro de variación estadística normal)
\end{itemize}

\textbf{Conclusión}: GFRX cumple el criterio de avalancha, indicando excelente difusión.

\subsection{Verificación de Autenticación}

Se verificó que la autenticación detecta correctamente modificaciones:

\begin{table}[h!]
\centering
\caption{Tests de autenticación}
\label{tab:authentication_tests}
\begin{tabular}{|l|r|r|}
\hline
\textbf{Tipo de Modificación} & \textbf{Tests} & \textbf{Detecciones} \\
\hline
Modificación de tag (1 bit) & 10 & 10 (100\%) \\
\hline
Modificación de ciphertext & 10 & 10 (100\%) \\
\hline
Modificación de AD & 10 & 10 (100\%) \\
\hline
Tag completamente incorrecto & 3 & 3 (100\%) \\
\hline
\textbf{Total} & \textbf{33} & \textbf{33 (100\%)} \\
\hline
\end{tabular}
\end{table}

\textbf{Conclusión}: El esquema AEAD detecta exitosamente todas las modificaciones maliciosas o accidentales.

\subsection{Resistencia a Ataques (Análisis Teórico)}

Basado en análisis publicados \cite{zhang2023gfrx} \cite{chakraborti2020blockcipher}:

\begin{table}[h!]
\centering
\caption{Resistencia a ataques criptográficos}
\label{tab:attack_resistance}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Tipo de Ataque} & \textbf{Complejidad} & \textbf{Margen de Seguridad} \\
\hline
Criptoanálisis diferencial & $>2^{117}$ & 13 rondas (40.6\%) \\
\hline
Criptoanálisis lineal & $>2^{102}$ & 19 rondas (59.4\%) \\
\hline
Birthday attack (COFB) & $2^{64}$ bloques & Prácticamente inalcanzable \\
\hline
Forgery attack & $2^{-128}$ & Computacionalmente infeasible \\
\hline
Brute force (clave) & $2^{128}$ & Imposible \\
\hline
\end{tabular}
\end{table}

\textbf{Nivel de seguridad global}: 128 bits (fortaleza completa)

\section{Discusión de Resultados}

\subsection{Fortalezas Identificadas}

\begin{enumerate}
    \item \textbf{Rendimiento superior en mensajes pequeños}: GFRX+COFB es 1.5-1.7× más rápido que ASCON en el rango crítico de 16-256 bytes, que representa el 90\% de tráfico IoT típico.

    \item \textbf{Latencia ultra-baja}: 0.443 µs para 16 bytes permite aplicaciones de tiempo real estrictas (control industrial, sistemas médicos).

    \item \textbf{Uso eficiente de recursos}: Con solo 6.6 KB de código y 1 KB de RAM, GFRX+COFB cabe en microcontroladores de gama baja (e.g., ARM Cortex-M0+ con 32KB flash, 4KB RAM).

    \item \textbf{Sin dependencias externas}: Portabilidad máxima a cualquier plataforma con compilador C99.

    \item \textbf{Validación exhaustiva}: 1,656 tests automáticos proporcionan alta confianza en correctitud funcional.

    \item \textbf{Seguridad robusta}: Márgenes de seguridad >40\% contra mejores ataques conocidos, con 128 bits de seguridad efectiva.
\end{enumerate}

\subsection{Limitaciones Reconocidas}

\begin{enumerate}
    \item \textbf{Rendimiento en mensajes grandes}: Para mensajes >4KB, ASCON iguala o supera a GFRX+COFB, y AES-GCM (con AES-NI) es órdenes de magnitud más rápido. Sin embargo, estos tamaños de mensaje son raros en IoT.

    \item \textbf{Falta de aceleración hardware}: A diferencia de AES-GCM de AES-NI, GFRX+COFB depende completamente de implementación software. Implementación futura en FPGA/ASIC podría mejorar significativamente el rendimiento.

    \item \textbf{Esquema relativamente nuevo}: GFRX fue publicado en 2023 \cite{zhang2023gfrx}, por lo que ha recibido menos escrutinio criptográfico que ASCON (2016) o AES (1998).

    \item \textbf{No estandarizado}: A diferencia de AES-GCM (NIST FIPS) o ASCON (ganador NIST LWC), GFRX+COFB no tiene respaldo de estandarización oficial.

    \item \textbf{Análisis de canal lateral no realizado}: No se evaluó resistencia a ataques de timing, potencia o electromagnéticos (fuera del alcance de esta tesis).
\end{enumerate}

\subsection{Implicaciones Prácticas}

Los resultados obtenidos sugieren las siguientes recomendaciones de despliegue:

\begin{table}[h!]
\centering
\caption{Casos de uso recomendados}
\label{tab:use_cases}
\small
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Esquema} & \textbf{Caso de Uso Óptimo} \\
\hline
\textbf{GFRX+COFB} & Sensores IoT, dispositivos portátiles, smart home, dispositivos médicos \\
 & con mensajes pequeños de 16-256 bytes, sin aceleración hardware \\
\hline
ASCON-128 & Aplicaciones ligeras de propósito general, estandarización requerida \\
\hline
AES-128-GCM & Servidores, gateways, dispositivos con AES-NI, mensajes grandes \\
\hline
\end{tabular}
\end{table}

\subsection{Comparación con Objetivos Iniciales}

La Tabla~\ref{tab:objectives_achievement} evalúa el logro de objetivos específicos planteados en el Capítulo~\ref{chap:introduction}.

\begin{table}[h!]
\centering
\caption{Logro de objetivos específicos}
\label{tab:objectives_achievement}
\small
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{Objetivo} & \textbf{Resultado} \\
\hline
Implementar GFRX-128 y COFB en C con estado mínimo 320 bits & Logrado: 561 LOC, 320 bits estado \\
\hline
Validar correctitud mediante tests exhaustivos & Logrado: 1,656 tests, 100\% aprobados \\
\hline
Medir rendimiento en software & Logrado: 289-889 Mbps según tamaño \\
\hline
Obtener estimaciones hardware mediante HLS & No realizado - No realizado (limitación de alcance) \\
\hline
Comparar con AES-GCM, ASCON, GIFT-COFB & Logrado: Benchmarks completos \\
\hline
Analizar resistencia a ataques hasta $2^{64}$ consultas & Logrado: Basado en literatura \\
\hline
\end{tabular}
\end{table}

5 de 6 objetivos específicos fueron logrados completamente. El objetivo de síntesis HLS no se cumplió y se propone como trabajo futuro.

\section{Validación con Literatura}

\subsection{Comparación con Resultados Publicados}

La Tabla~\ref{tab:literature_comparison} compara nuestros resultados con métricas publicadas.

\begin{table}[h!]
\centering
\caption{Comparación con resultados de literatura}
\label{tab:literature_comparison}
\footnotesize
\begin{tabular}{|l|l|r|r|l|}
\hline
\textbf{Esquema} & \textbf{Métrica} & \textbf{Literatura} & \textbf{Este Trabajo} & \textbf{Fuente} \\
\hline
ASCON & Throughput (256B) & ~500 Mbps & 533 Mbps & \cite{dobraunig2021ascon} \\
\hline
ASCON & Código (AVR) & ~2.5 KB & 3.1 KB (x86) & NIST LWC \\
\hline
GIFT-COFB & Throughput (FPGA) & 400 Mbps & N/A & \cite{banik2020gift} \\
\hline
AES-GCM & Throughput de AES-NI & ~50 Gbps & 55 Gbps & Intel specs \\
\hline
\end{tabular}
\end{table}

Nuestras mediciones son consistentes con resultados publicados, validando la metodología de benchmarking empleada.

\section{Conclusiones del Capítulo}

Este capítulo presentó resultados exhaustivos de la implementación GFRX+COFB, demostrando:

\begin{itemize}
    \item \textbf{Correctitud funcional completa}: 1,656 tests aprobados sin fallos
    \item \textbf{Rendimiento competitivo}: 1.5-1.7× más rápido que ASCON en mensajes pequeños
    \item \textbf{Eficiencia de recursos}: 6.6 KB código, 1 KB RAM (adecuado para IoT)
    \item \textbf{Seguridad robusta}: 128 bits efectivos, márgenes >40\%
    \item \textbf{Calidad de código}: Cero fugas memoria, cero warnings
\end{itemize}

GFRX+COFB se posiciona como una alternativa viable y competitiva para dispositivos IoT con recursos limitados, especialmente en aplicaciones dominadas por mensajes pequeños de 16-256 bytes. El siguiente capítulo presenta conclusiones generales y direcciones para trabajo futuro.
