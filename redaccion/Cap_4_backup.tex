\chapter{Implementación}
\label{chap:implementation}

Este capítulo presenta la implementación completa del esquema GFRX+COFB, describiendo las decisiones de diseño, la estructura del código, los algoritmos implementados y la metodología de validación empleada. La implementación se desarrolló en lenguaje C siguiendo el estándar C99, priorizando la portabilidad, eficiencia y claridad del código para servir como referencia funcional del primer esquema GFRX+COFB.

\section{Visión General de la Implementación}

La implementación de GFRX+COFB se estructuró en tres módulos principales, cada uno con responsabilidades claramente definidas, siguiendo principios de modularidad y separación de responsabilidades.

\subsection{Arquitectura Modular}

La arquitectura implementada consta de los siguientes componentes.

\begin{itemize}
    \item \textbf{Módulo GFRX} en el archivo \texttt{gfrx.c} de 146 líneas implementa el cifrado de bloque GFRX-128/128 con sus funciones de ronda y expansión de clave.
    \item \textbf{Módulo COFB} en el archivo \texttt{cofb.c} de 397 líneas implementa el modo de operación COFB incluyendo procesamiento de datos asociados, cifrado/descifrado de mensajes y generación/verificación de tags.
    \item \textbf{Módulo de Utilidades} en el archivo \texttt{utils.c} de 18 líneas proporciona funciones de seguridad críticas para comparación constante en tiempo y limpieza segura de memoria.
\end{itemize}

El diseño modular permite la reutilización independiente del cifrado de bloque GFRX y facilita pruebas unitarias de cada componente.

\subsection{Decisiones de Diseño}

Las principales decisiones de diseño tomadas se describen a continuación.

\begin{enumerate}
    \item \textbf{Lenguaje C estándar C99} fue seleccionado por su portabilidad, eficiencia y idoneidad para sistemas embebidos. El estándar C99 proporciona tipos de datos de tamaño fijo como \texttt{uint8\_t} y \texttt{uint32\_t}, esenciales para implementaciones criptográficas deterministas.

    \item \textbf{Sin dependencias externas}, la implementación núcleo no requiere bibliotecas externas. Únicamente depende de la biblioteca estándar de C con los headers \texttt{stdint.h} y \texttt{string.h}, maximizando la portabilidad entre plataformas.

    \item \textbf{Gestión de memoria basada en pila} donde toda la gestión de memoria utiliza asignación en stack. Se evita completamente asignación dinámica mediante \texttt{malloc} y \texttt{free}, eliminando fugas de memoria y haciendo la implementación adecuada para sistemas de tiempo real.

    \item \textbf{API orientada a contextos} utiliza estructuras de contexto como \texttt{gfrx\_ctx\_t} y \texttt{cofb\_ctx\_t} que encapsulan el estado interno, permitiendo múltiples instancias independientes simultáneas.
\end{enumerate}

\section{Entorno de Desarrollo}

\subsection{Herramientas Utilizadas}

La Tabla~\ref{tab:dev_tools_used} presenta las herramientas empleadas durante el desarrollo.

\begin{table}[h!]
\centering
\caption{Herramientas de desarrollo utilizadas}
\label{tab:dev_tools_used}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Categoría} & \textbf{Herramienta} & \textbf{Uso} \\
\hline
Compilador & GCC 9.4+ / Clang 10+ & Compilación con \texttt{-O2 -std=c99} \\
\hline
Control de versiones & Git 2.34+ & Gestión de código fuente \\
\hline
Análisis estático & GCC warnings & \texttt{-Wall -Wextra} \\
\hline
Detección de fugas & Valgrind 3.18+ & Análisis de memoria \\
\hline
Profiling CPU & gprof & Identificación de hotspots \\
\hline
Sanitizers & AddressSanitizer & Detección de errores de memoria \\
 & UndefinedBehaviorSanitizer & Detección de comportamiento indefinido \\
\hline
Testing & Framework propio & 1,656 tests exhaustivos \\
\hline
Benchmarking & \texttt{clock\_gettime()} & Medición precisa de rendimiento \\
\hline
\end{tabular}
\end{table}

\subsection{Plataforma de Desarrollo}

\begin{itemize}
    \item \textbf{Sistema Operativo} Linux Ubuntu 22.04 LTS y macOS con soporte Homebrew
    \item \textbf{Arquitectura} x86-64 para desarrollo y benchmarking
    \item \textbf{Flags de compilación} configurados como \texttt{-Wall -Wextra -O2 -std=c99}
    \item \textbf{Sistema de construcción} Makefile profesional con 14 targets
\end{itemize}

El diseño es portable y compatible con arquitecturas embebidas como ARM Cortex-M y RISC-V, aunque las evaluaciones se realizaron en x86-64.

\section{Estructura del Código}

\subsection{Organización de Directorios}

La estructura del proyecto sigue una organización estándar para bibliotecas C.

\begin{verbatim}
implementacion/
|-- include/                  # Cabeceras publicas
|   |-- gfrx_cofb.h          # API principal GFRX+COFB
|   |-- ascon.h              # API ASCON para comparacion
|   |-- aes_gcm.h            # API AES-GCM para comparacion
|   +-- gift_cofb.h          # API GIFT-COFB para comparacion
|-- src/                      # Implementaciones
|   |-- gfrx.c               # Cifrado GFRX-128
|   |-- cofb.c               # Modo COFB
|   |-- utils.c              # Utilidades de seguridad
|   |-- ascon.c              # ASCON-128
|   |-- aes_gcm.c            # AES-128-GCM wrapper OpenSSL
|   |-- gift.c               # GIFT-128
|   +-- gift_cofb.c          # GIFT-COFB
|-- test/                     # Suite de pruebas
|   +-- test_gfrx_cofb.c     # 1,656 tests automatizados
|-- build/                    # Objetos compilados
|-- bin/                      # Ejecutables
+-- Makefile                  # Sistema de construccion
\end{verbatim}

\subsection{Convenciones de Nomenclatura}

Se siguieron convenciones consistentes para mejorar la legibilidad.

\begin{itemize}
    \item \textbf{Funciones} utilizan \texttt{snake\_case} con prefijo de módulo como \texttt{gfrx\_*} o \texttt{cofb\_*}
    \item \textbf{Variables} utilizan \texttt{snake\_case} descriptivo
    \item \textbf{Tipos} incluyen sufijo \texttt{\_t} como en \texttt{byte\_t}, \texttt{word32\_t} o \texttt{gfrx\_ctx\_t}
    \item \textbf{Constantes y Macros} utilizan \texttt{UPPER\_CASE} como en \texttt{GFRX\_BLOCK\_SIZE}
\end{itemize}

\section{Implementación del Cifrado GFRX}

\subsection{Parámetros y Tipos de Datos}

El módulo GFRX define los siguientes parámetros.

\begin{itemize}
    \item \textbf{Tamaño de bloque} de 128 bits equivalentes a 16 bytes
    \item \textbf{Tamaño de clave} de 128 bits equivalentes a 16 bytes
    \item \textbf{Número de rondas} de 32 en red Feistel
    \item \textbf{Tipos básicos} \texttt{byte\_t} de 8 bits y \texttt{word32\_t} de 32 bits
\end{itemize}

La estructura de contexto \texttt{gfrx\_ctx\_t} almacena el programa de claves expandido, que consiste en 32 subclaves de 32 bits cada una totalizando 128 bytes.

\subsection{Funciones de Ronda}

GFRX utiliza dos tipos de funciones de ronda basadas en operaciones ARX de adición, rotación y XOR.

\begin{enumerate}
    \item \textbf{FAN o Function AND} proporciona no-linealidad mediante la operación AND entre dos palabras previamente rotadas. La primera palabra se rota 19 posiciones a la izquierda, la segunda se rota 3 posiciones a la izquierda, y el resultado es el AND de ambas rotaciones.

    \item \textbf{FADL y FADR o Function ADD Left/Right} proporcionan difusión mediante suma aritmética seguida de rotación. FADL suma las dos palabras y rota el resultado 1 posición a la izquierda. FADR suma las dos palabras y rota el resultado 1 posición a la derecha.
\end{enumerate}

Estas funciones fueron implementadas como funciones estáticas inline para maximizar el rendimiento mediante optimización del compilador.

\subsection{Expansión de Clave}

El algoritmo de expansión de clave genera 32 subclaves de 32 bits a partir de la clave maestra de 128 bits. El proceso sigue los siguientes pasos.

\begin{enumerate}
    \item La clave maestra de 128 bits se divide en cuatro palabras de 32 bits denotadas como \texttt{k[0]}, \texttt{k[1]}, \texttt{k[2]} y \texttt{k[3]}.
    \item Para cada ronda $i$ de 0 a 31 se ejecutan las siguientes operaciones
    \begin{itemize}
        \item La subclave de ronda se genera como $k[i \bmod 4] \oplus (i \times \text{0x9e3779b9})$
        \item La palabra $k[i \bmod 4]$ se actualiza rotándola 7 posiciones a la izquierda
    \end{itemize}
    \item La constante hexadecimal 0x9e3779b9 corresponde a la razón áurea en punto fijo de 32 bits, utilizada para romper simetrías.
\end{enumerate}

Este esquema de expansión es eficiente y proporciona buena difusión de la clave maestra a través de todas las subclaves.

\subsection{Cifrado de Bloque}

La función de cifrado implementa la red Feistel generalizada de 4 ramas siguiendo estos pasos.

\begin{enumerate}
    \item El bloque de entrada de 128 bits se divide en cuatro palabras de 32 bits denotadas como $L_0$, $L_1$, $R_0$ y $R_1$.

    \item Para cada ronda $i$ de 0 a 31 se ejecutan las siguientes transformaciones
    \begin{itemize}
        \item Se aplica la función no-lineal FAN mediante $L_0' = R_0 \oplus \text{FAN}(L_0, L_1)$
        \item Se aplica la función de difusión FADL mediante $L_1' = R_1 \oplus \text{FADL}(L_0, L_1)$
        \item Se realiza el intercambio Feistel con $R_0' = L_0$ y $R_1' = L_1$
        \item Se mezcla la subclave mediante $L_0' = L_0' \oplus k_i$
    \end{itemize}

    \item Las cuatro palabras finales se concatenan para formar el bloque cifrado de 128 bits.
\end{enumerate}

\subsection{Descifrado de Bloque}

El descifrado invierte el proceso de cifrado aplicando las rondas en orden inverso. Los pasos se describen a continuación.

\begin{enumerate}
    \item El bloque cifrado se divide en cuatro palabras.
    \item Para cada ronda $i$ de 31 a 0 en orden inverso se ejecutan las transformaciones
    \begin{itemize}
        \item Se desmezcla la subclave mediante $L_0 = L_0 \oplus k_i$
        \item Se invierten las transformaciones Feistel
        \item Se aplican las funciones inversas
    \end{itemize}
    \item Las palabras resultantes se concatenan para formar el bloque en claro.
\end{enumerate}

\section{Implementación del Modo COFB}

\subsection{Estructura de Contexto COFB}

El contexto COFB denotado como \texttt{cofb\_ctx\_t} encapsula dos componentes.

\begin{itemize}
    \item \textbf{Contexto del cifrado} es una instancia del contexto GFRX con el programa de claves expandido ocupando 128 bytes.
    \item \textbf{Constante L} es un bloque de 128 bits precalculado como $L = E_K(0^{128})$ y se utiliza para generar máscaras.
\end{itemize}

El tamaño total del contexto COFB es de 144 bytes conformados por 128 bytes del programa de claves más 16 bytes de la constante L.

\subsection{Inicialización}

La función de inicialización \texttt{cofb\_init} realiza dos operaciones.

\begin{enumerate}
    \item Inicializa el contexto del cifrado de bloque GFRX con la clave maestra.
    \item Calcula la constante $L$ cifrando un bloque de ceros mediante $L = \text{GFRX}_K(0^{128})$.
\end{enumerate}

Esta constante $L$ se utiliza posteriormente para generar todas las máscaras del modo COFB mediante multiplicación en $\text{GF}(2^{64})$.

\subsection{Generación de Máscaras}

COFB utiliza máscaras de 64 bits generadas mediante multiplicación en el campo de Galois $\text{GF}(2^{64})$. La función \texttt{delta} implementa esta operación mediante los siguientes pasos.

\begin{enumerate}
    \item La multiplicación por 2 en $\text{GF}(2^{64})$ se realiza mediante desplazamiento izquierdo de 1 bit.
    \item Si el bit más significativo es 1, se realiza una reducción XOR con el polinomio $x^{64} + x^4 + x^3 + x + 1$ representado como 0x87.
    \item Se realiza un XOR adicional con un byte de dominio que puede ser 0x00 para AD, 0x01 para mensaje o 0x02 para tag con el fin de separar criptográficamente los contextos.
\end{enumerate}

\subsection{Función de Transformación Lineal G}

La función $G$ es una transformación lineal invertible definida como $G(X) = 2X \oplus X$, donde la multiplicación es en $\text{GF}(2^{128})$. Los pasos de implementación se describen a continuación.

\begin{enumerate}
    \item Duplicar el valor de entrada mediante $Y = 2X$ aplicando desplazamiento izquierdo con reducción.
    \item Calcular $G(X) = Y \oplus X$.
\end{enumerate}

Esta función se utiliza para actualizar el estado interno durante el procesamiento de bloques.

\subsection{Cifrado AEAD}

El cifrado AEAD procesa datos asociados y mensaje en un solo paso mediante las siguientes etapas.

\begin{enumerate}
    \item \textbf{Inicialización del estado} donde el estado inicial de 128 bits se forma concatenando el nonce de 64 bits con 64 bits de ceros.

    \item \textbf{Procesamiento de datos asociados} donde para cada bloque de AD se ejecutan las operaciones
    \begin{itemize}
        \item Se genera una máscara mediante \texttt{delta} con dominio 0x00
        \item Se aplica la función $G$ al estado
        \item Se procesa el bloque de AD mediante XOR con el estado
    \end{itemize}

    \item \textbf{Procesamiento del mensaje} donde para cada bloque del mensaje se ejecutan las operaciones
    \begin{itemize}
        \item Se genera una máscara mediante \texttt{delta} con dominio 0x01
        \item Se cifra el bloque aplicando XOR entre plaintext y estado
        \item Se actualiza el estado mediante la función $G$
    \end{itemize}

    \item \textbf{Generación del tag} donde se genera una máscara final con dominio 0x02 y se cifra el estado para obtener el tag de autenticación de 128 bits.

    \item \textbf{Limpieza} donde se limpia el contexto de memoria utilizando \texttt{secure\_zero} para prevenir fuga de claves.
\end{enumerate}

\subsection{Descifrado y Verificación}

El descifrado AEAD invierte el proceso de cifrado e incluye verificación de autenticidad mediante las siguientes etapas.

\begin{enumerate}
    \item Se procesan los datos asociados de manera idéntica al cifrado.
    \item Se descifra el mensaje aplicando XOR entre ciphertext y estado.
    \item Se calcula el tag esperado siguiendo el mismo proceso que en cifrado.
    \item Se verifica el tag utilizando \texttt{secure\_compare} que implementa comparación constante en tiempo.
    \item Si la verificación falla, se borra el plaintext resultante y se retorna error de autenticación.
\end{enumerate}

La comparación constante en tiempo es crítica para prevenir ataques de temporización que podrían revelar información sobre el tag correcto.

\section{Utilidades de Seguridad}

\subsection{Comparación Constante en Tiempo}

La función \texttt{secure\_compare()} implementa comparación de memoria en tiempo constante para prevenir ataques de temporización durante la verificación de tags. Las características principales se describen como

\begin{itemize}
    \item Utiliza el operador OR bit a bit para acumular todas las diferencias sin cortocircuito.
    \item La palabra clave \texttt{volatile} previene optimizaciones del compilador que podrían introducir variabilidad temporal.
    \item El tiempo de ejecución es constante independientemente de dónde ocurran las diferencias.
    \item Recorre siempre toda la longitud especificada, evitando terminación temprana.
\end{itemize}

Esta función es esencial para la seguridad del esquema AEAD, ya que comparaciones naive pueden filtrar información sobre el tag correcto bit a bit.

\subsection{Limpieza Segura de Memoria}

La función \texttt{secure\_zero()} previene fuga de material criptográfico sensible (claves, nonces, estados internos) mediante limpieza garantizada de memoria:

\begin{itemize}
    \item Utiliza punteros \texttt{volatile} para forzar escritura de ceros en memoria.
    \item Previene que el compilador elimine la operación como "código muerto".
    \item Garantiza que claves y datos sensibles no permanezcan en memoria después de uso.
\end{itemize}

Esta función se invoca sistemáticamente al finalizar operaciones criptográficas para minimizar la ventana de exposición de material sensible.

\section{Sistema de Construcción}

\subsection{Makefile Profesional}

El Makefile implementado proporciona 14 targets para diferentes flujos de trabajo, mostrados en la Tabla~\ref{tab:makefile_targets}.

\begin{table}[h!]
\centering
\caption{Targets del Makefile}
\label{tab:makefile_targets}
\small
\begin{tabular}{|l|p{9cm}|}
\hline
\textbf{Target} & \textbf{Descripción} \\
\hline
\texttt{make} & Construir biblioteca estática y todos los ejecutables \\
\hline
\texttt{make test} & Construir y ejecutar suite de pruebas (1,656 tests) \\
\hline
\texttt{make clean} & Eliminar artefactos de construcción \\
\hline
\texttt{make debug} & Construir con AddressSanitizer y UndefinedBehaviorSanitizer \\
\hline
\texttt{make profile} & Construir con soporte para gprof (profiling de CPU) \\
\hline
\texttt{make asm} & Generar salida en ensamblador para análisis de optimización \\
\hline
\texttt{make memcheck} & Ejecutar Valgrind para detección de fugas de memoria \\
\hline
\texttt{make gprof} & Ejecutar profiling y generar análisis de rendimiento \\
\hline
\texttt{make install} & Instalar biblioteca y headers en \texttt{/usr/local/} \\
\hline
\texttt{make uninstall} & Desinstalar archivos instalados \\
\hline
\end{tabular}
\end{table}

\subsection{Detección Automática de Plataforma}

El Makefile detecta automáticamente la plataforma en Linux y macOS y ajusta las rutas de OpenSSL según corresponda.

\begin{itemize}
    \item En macOS, detecta la instalación de OpenSSL mediante Homebrew (\texttt{/opt/homebrew/opt/openssl@3} o \texttt{/usr/local/opt/openssl@3}).
    \item En Linux, utiliza las rutas estándar del sistema (\texttt{/usr/include}, \texttt{/usr/lib}).
    \item Esta detección solo afecta al benchmark de comparación (\texttt{comparison\_benchmark}), que requiere OpenSSL para AES-GCM.
\end{itemize}

El core de GFRX+COFB no tiene dependencias de OpenSSL y compila en cualquier plataforma con compilador C99.

\section{Metodología de Validación}

\subsection{Suite de Pruebas Exhaustiva}

Se implementó una suite de 1,656 tests automatizados que cubren todos los aspectos funcionales de GFRX+COFB. La distribución de tests se describe a continuación.

\begin{enumerate}
    \item \textbf{Pruebas básicas GFRX} con 102 tests:
    \begin{itemize}
        \item Cifrado y descifrado de bloques individuales
        \item Verificación de consistencia mediante 100 rondas de cifrado/descifrado
        \item Validación del programa de claves expandido
    \end{itemize}

    \item \textbf{Pruebas COFB modo AEAD} con 541 tests:
    \begin{itemize}
        \item Mensaje vacío como caso extremo crítico
        \item Mensajes con y sin datos asociados
        \item Longitudes variables de 0 a 512 bytes totalizando 513 tests exhaustivos
        \item Verificación correcta de autenticación
        \item Comportamiento con nonces únicos
    \end{itemize}

    \item \textbf{Pruebas de seguridad} con 23 tests:
    \begin{itemize}
        \item Detección de modificación de tag con 10 tests
        \item Detección de modificación de datos asociados con 10 tests
        \item Verificación del efecto avalancha mediante 1 test
        \item Verificación de unicidad de nonce con 2 tests
    \end{itemize}

    \item \textbf{Pruebas de estrés} con 1000 tests:
    \begin{itemize}
        \item 1000 operaciones consecutivas de cifrado y descifrado
        \item Verificación de estabilidad a largo plazo
        \item Detección de fugas de memoria acumuladas
    \end{itemize}
\end{enumerate}

\subsection{Herramientas de Análisis Dinámico}

\subsubsection{Valgrind - Detección de Fugas de Memoria}

La ejecución de la suite de tests bajo Valgrind confirmó la ausencia total de fugas de memoria:

\begin{itemize}
    \item \textbf{Heap en uso al finalizar}: 0 bytes en 0 bloques
    \item \textbf{Total de asignaciones heap}: 0 asignaciones, 0 liberaciones, 0 bytes
    \item \textbf{Conclusión}: Todos los bloques heap liberados correctamente dado que no se usa heap
    \item \textbf{Resumen de errores}: 0 errores detectados
\end{itemize}

Este resultado valida la decisión de diseño de evitar completamente asignación dinámica de memoria.

\subsubsection{AddressSanitizer - Detección de Errores de Memoria}

La compilación con \texttt{-fsanitize=address,undefined} y ejecución de todos los tests no detectó ningún error:

\begin{itemize}
    \item Sin desbordamientos de buffer de stack o heap
    \item Sin accesos a memoria liberada de use-after-free
    \item Sin accesos a memoria no inicializada
    \item Sin comportamiento indefinido en operaciones aritméticas
\end{itemize}

\subsubsection{gprof - Profiling de CPU}

El análisis de hotspots de CPU reveló una distribución balanceada del tiempo de ejecución, mostrada en la Tabla~\ref{tab:cpu_hotspots}.

\begin{table}[h!]
\centering
\caption{Distribución de tiempo de CPU de hotspots}
\label{tab:cpu_hotspots}
\begin{tabular}{|l|r|r|}
\hline
\textbf{Función} & \textbf{\% Tiempo} & \textbf{Llamadas} \\
\hline
\texttt{gfrx\_encrypt\_block} & 50.0\% & 108,834 \\
\hline
\texttt{cofb\_encrypt} & 50.0\% & 2,561 \\
\hline
\texttt{G\_function} & $<$0.1\% & 94,628 \\
\hline
\texttt{secure\_compare} & $<$0.1\% & 1,542 \\
\hline
\end{tabular}
\end{table}

\textbf{Conclusión}: El diseño es balanceado sin cuellos de botella dominantes. El 50\% del tiempo se consume en el cifrado de bloque GFRX y el otro 50\% en la lógica del modo COFB. Las funciones de seguridad (\texttt{secure\_compare}, \texttt{secure\_zero}) tienen overhead despreciable.

\subsection{Vectores de Prueba Documentados}

Se generaron 10 vectores de prueba oficiales para garantizar reproducibilidad y permitir validación de implementaciones independientes:

\begin{enumerate}
    \item Cifrado básico GFRX-128 sin modo AEAD
    \item COFB con mensaje vacío de 0 bytes
    \item COFB con mensaje de 8 bytes de bloque parcial
    \item COFB con mensaje de 16 bytes de un bloque completo
    \item COFB con mensaje de 64 bytes de cuatro bloques
    \item COFB con datos asociados y mensaje
    \item COFB con mensaje de texto legible
    \item Caso con clave y nonce todo-ceros
    \item Caso con clave y mensaje todo-unos de 0xFF
    \item Mensaje largo de 256 bytes
\end{enumerate}

Todos los vectores están documentados en formato hexadecimal en el archivo \texttt{TEST\_VECTORS\_DOCUMENTATION.md} con estructura estandarizada que incluye clave, nonce, datos asociados (opcional), plaintext, ciphertext esperado y tag de autenticación.

\section{Métricas de la Implementación}

\subsection{Tamaño del Código}

La Tabla~\ref{tab:code_size_implementation} muestra las métricas de tamaño de la implementación core.

\begin{table}[h!]
\centering
\caption{Tamaño del código implementado}
\label{tab:code_size_implementation}
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Módulo} & \textbf{Código (bytes)} & \textbf{Líneas} & \textbf{\% del Core} \\
\hline
\texttt{gfrx.c} & 1,032 & 146 & 15.2\% \\
\hline
\texttt{cofb.c} & 5,537 & 397 & 81.7\% \\
\hline
\texttt{utils.c} & 209 & 18 & 3.1\% \\
\hline
\textbf{Total Core} & \textbf{6,778} & \textbf{561} & \textbf{100\%} \\
\hline
\end{tabular}
\end{table}

La biblioteca core de GFRX+COFB ocupa únicamente 6.6 KB de memoria de programa, lo cual es adecuado para dispositivos IoT típicos con 32 KB o más de memoria flash. Para comparación, microcontroladores como el ATmega328P (Arduino Uno) tienen 32 KB de flash, y el ESP8266 tiene 4 MB, por lo que GFRX+COFB representa menos del 0.02\% de la memoria de programa disponible en estos dispositivos.

\subsection{Uso de Memoria RAM}

El uso de memoria RAM durante la ejecución se desglosa de la siguiente manera:

\begin{itemize}
    \item \textbf{Contexto GFRX}: 128 bytes (32 subclaves × 4 bytes c/u)
    \item \textbf{Contexto COFB}: 144 bytes (contexto GFRX + constante L de 16 bytes)
    \item \textbf{Stack para mensaje de 256 bytes}: aproximadamente 1.2 KB
    \item \textbf{Heap}: 0 bytes (sin asignaciones dinámicas)
    \item \textbf{Total RAM para mensaje típico de 256 bytes}: aproximadamente 1.5 KB
\end{itemize}

Este uso de memoria es compatible con dispositivos IoT que típicamente tienen 4 KB o más de SRAM, como el ATmega328P (2 KB SRAM), STM32F103 (20 KB SRAM), o ESP8266 (80 KB SRAM).

\section{Desafíos de Implementación y Soluciones}

\subsection{Aritmética en GF(2\textsuperscript{64})}

\textbf{Problema}: La generación de máscaras en COFB requiere multiplicación en el campo de Galois $\text{GF}(2^{64})$, que no es una operación nativa en procesadores estándar.

\textbf{Solución}: Se implementó multiplicación por 2 mediante desplazamientos bit a bit con reducción condicional. El polinomio irreducible $x^{64} + x^4 + x^3 + x + 1$ se representa como la constante 0x87. La implementación:

\begin{itemize}
    \item Realiza desplazamiento izquierdo de todos los bytes
    \item Propaga los bits de carry entre bytes adyacentes
    \item Aplica XOR con 0x87 si el bit más significativo original era 1
    \item Complejidad temporal: $O(1)$ con 8 operaciones independientes del tamaño de datos
\end{itemize}

\subsection{Padding de Bloques Parciales}

\textbf{Problema}: COFB requiere esquema de padding 10* que agrega bit 1 seguido de bits 0 para mensajes que no son múltiplos del tamaño de bloque. Un padding incorrecto compromete la seguridad del esquema.

\textbf{Solución}: Implementación cuidadosa del esquema 10*:

\begin{itemize}
    \item Copiar los bytes restantes del último bloque
    \item Agregar el byte 0x80 de bit 1 seguido de siete 0s inmediatamente después
    \item Llenar el resto del bloque con ceros
    \item Validar que el padding se aplica solo cuando es necesario
\end{itemize}

Esta implementación fue exhaustivamente probada con los 513 tests de longitudes variables.

\subsection{Prevención de Ataques de Temporización}

\textbf{Problema}: La comparación naive de tags mediante \texttt{memcmp()} o bucles con terminación temprana puede filtrar información sobre el tag correcto mediante análisis de temporización, permitiendo ataques de falsificación.

\textbf{Solución}: Implementación de comparación constante en tiempo mediante:

\begin{itemize}
    \item Acumulación de diferencias mediante operador OR bit a bit sin cortocircuito
    \item Uso de palabra clave \texttt{volatile} para prevenir optimizaciones del compilador
    \item Recorrido completo de toda la longitud del tag sin terminación temprana
    \item Retorno de resultado solo después de procesar todos los bytes
\end{itemize}

Esta técnica garantiza que el tiempo de ejecución es independiente de la posición o cantidad de diferencias entre tags.

\subsection{Portabilidad entre Plataformas}

\textbf{Problema}: Diferentes arquitecturas tienen diferentes convenciones de endianness (little-endian vs big-endian) y diferentes tamaños de tipos primitivos (\texttt{int}, \texttt{long}), lo que puede causar resultados inconsistentes.

\textbf{Solución}:

\begin{itemize}
    \item Uso exclusivo de tipos de tamaño fijo del estándar C99 (\texttt{uint8\_t}, \texttt{uint32\_t})
    \item Conversiones explícitas de endianness mediante operaciones de desplazamiento y OR
    \item Evitar asumir alineación de memoria evitando casting directo de punteros
    \item Evitar comportamiento dependiente de implementación como rotaciones implementadas explícitamente)
\end{itemize}

Estas medidas garantizan que la implementación produce resultados idénticos en arquitecturas x86-64, ARM, RISC-V y AVR.

\section{Lecciones Aprendidas}

\subsection{Aspectos Exitosos}

\begin{enumerate}
    \item \textbf{Diseño modular}: La separación entre GFRX (cifrado de bloque) y COFB (modo AEAD) facilitó enormemente el desarrollo, testing y debugging independiente de cada componente.

    \item \textbf{Testing exhaustivo}: Los 1,656 tests automatizados detectaron múltiples errores sutiles durante el desarrollo, especialmente en casos extremos como mensajes vacíos, bloques parciales y verificación de padding.

    \item \textbf{Herramientas de análisis}: AddressSanitizer, UndefinedBehaviorSanitizer y Valgrind detectaron errores que habrían sido muy difíciles de identificar mediante testing manual.

    \item \textbf{Gestión de memoria simplificada}: La decisión de evitar asignación dinámica eliminó una clase completa de errores potenciales (fugas de memoria, double-free, use-after-free).

    \item \textbf{Documentación temprana}: Documentar los vectores de prueba y decisiones de diseño desde el principio facilitó el desarrollo y servirá para futuras implementaciones.
\end{enumerate}

\subsection{Aspectos a Mejorar}

\begin{enumerate}
    \item \textbf{Documentación inline}: Aunque el código es legible, mayor documentación inline en las funciones críticas facilitaría el mantenimiento futuro por otros desarrolladores.

    \item \textbf{Optimización específica de plataforma}: La implementación actual prioriza portabilidad sobre rendimiento máximo. Versiones optimizadas para arquitecturas específicas (usando intrínsecos SIMD, instrucciones de rotación nativas, etc.) podrían mejorar significativamente el throughput.

    \item \textbf{Análisis de timing empírico}: Aunque se implementaron funciones constantes en tiempo, no se realizó análisis empírico detallado de timing para validar experimentalmente la resistencia a ataques de temporización en plataformas reales.

    \item \textbf{Cobertura de código}: No se midió la cobertura de código de los tests. Herramientas como \texttt{gcov} podrían identificar ramas no ejercitadas por la suite de pruebas.
\end{enumerate}

\section{Conclusiones del Capítulo}

Este capítulo presentó la implementación completa de GFRX+COFB en 561 líneas de código C estándar C99, estructurada en tres módulos bien definidos con cifrado de bloque GFRX de 146 líneas, modo AEAD COFB de 397 líneas y utilidades de seguridad de 18 líneas. La implementación cumple con todos los requisitos funcionales establecidos.

\begin{itemize}
    \item \textbf{Funcionalidad completa} mediante cifrado y descifrado AEAD con soporte para datos asociados opcionales.
    \item \textbf{Validación exhaustiva} con 1,656 tests automatizados que cubren todos los escenarios relevantes, todos aprobados exitosamente.
    \item \textbf{Sin fugas de memoria} verificado mediante Valgrind y AddressSanitizer sin errores detectados.
    \item \textbf{Código compacto} de 6.6 KB de biblioteca core, adecuado para dispositivos con 32 KB o más de flash.
    \item \textbf{Bajo uso de RAM} de aproximadamente 1.5 KB para mensajes típicos, compatible con dispositivos con 4 KB o más de SRAM.
    \item \textbf{Portabilidad} mediante C99 estándar sin dependencias externas utilizando solo biblioteca estándar.
    \item \textbf{Seguridad} con implementación de comparación constante en tiempo y limpieza segura de memoria.
\end{itemize}

La implementación sirve como referencia funcional para GFRX+COFB y proporciona una base sólida para futuras optimizaciones específicas de plataforma y eventual implementación en hardware. El siguiente capítulo presenta los resultados experimentales obtenidos mediante benchmarking de la implementación y análisis comparativo con esquemas AEAD establecidos del estado del arte.
